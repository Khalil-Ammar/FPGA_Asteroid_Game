#include <stdio.h>
#include <math.h>
#include "platform.h"
#include "xil_printf.h"

#include "xil_types.h"
#include "xstatus.h"
#include "xllfifo.h"
#include "xscugic.h"
#include "xaxidma.h"
#include "xparameters.h"

// Size of the buffer holding the DMA Buffer Descriptors (BDs)
#define DMA_BDUFFERSIZE 4000

typedef struct
{
	XLlFifo spiFifoController;
	u8 spiChipAddr;
	int spiFifoWordsize;
	
	XAxiDma dmaAxiController;
	XAxiDma_Bd dmaBdBuffer[DMA_BDUFFERSIZE] __attribute__((aligned(XAXIDMA_BD_MINIMUM_ALIGNMENT)));
	int dmaWritten;
} adau1761_config;

int adau1761_init(adau1761_config *pDevice, u32 DeviceId, u16 dmaId, u16 interruptId);
int adau1761_checkInit(adau1761_config *pDevice);
void adau1761_write(adau1761_config *pDevice,u16 addr, u8 wdata);
u8 adau1761_read(adau1761_config *pDevice,u16 addr);
int adau1761_dmaSetup(adau1761_config *pDevice);
void adau1761_dmaFreeProcessedBDs(adau1761_config *pDevice);
int adau1761_dmaBusy(adau1761_config *pDevice);
void adau1761_dmaReset(adau1761_config *pDevice);

int adau1761_init(adau1761_config *pDevice, u32 DeviceId, u16 dmaId, u16 interruptId) {
	pDevice->spiChipAddr = 0;
	pDevice->spiFifoWordsize = 4;
	pDevice->dmaWritten = FALSE;

	XLlFifo_Config *pConfig = XLlFfio_LookupConfig(DeviceId);
	int xStatus = XLlFifo_CfgInitialize(&pDevice->spiFifoController,pConfig,pConfig->BaseAddress);
	if(XST_SUCCESS != xStatus) {
		return -1;
	}

	// Check for the Reset value
	u32 Status = XLlFifo_Status(&pDevice->spiFifoController);
	XLlFifo_IntClear(&pDevice->spiFifoController,0xffffffff);
	Status = XLlFifo_Status(&pDevice->spiFifoController);
	if(Status != 0) {
		return -2;
	}

	// This enables SPI mode
	adau1761_read(pDevice, 0x4000);
	adau1761_read(pDevice, 0x4000);
	adau1761_read(pDevice, 0x4000);

	// Enable clock
	adau1761_write(pDevice, 0x4000, 0x01);

	// SLEWPD=1, ALCPD=1, DECPD=1, SOUTPD=1, INTPD=1, SINPD=1, SPPD=1
	adau1761_write(pDevice, 0x40F9, 0x7F);
	// CLK1=0, CLK0=1
	adau1761_write(pDevice, 0x40FA, 0x01);

	// MX3LM=1, MX3RM=0, MX3G1=0, MX3G2=0, MX3AUXG=0, MX5G3=3, MX6G3=0, LOUTVOL=63
	// MX4LM=0, MX4RM=1, MX4G1=0, MX4G2=0, MX4AUXG=0, MX5G4=0, MX6G4=3, ROUTVOL=63

	// LRCLK/LRPOL=falling edge, LRCLK/LRMOD=50%, BCLK/BPOL=falloing edge, LRDEL=1
	// SPSRS=0, LRMOD=0, BPOL=0, LRPOL=0, CHPF=0, MS=0
	adau1761_write(pDevice, 0x4015, 0x00);
	// BPF=0, ADTDM=0, DATDM=0, MSBP=0, LRDEL=0
	adau1761_write(pDevice, 0x4016, 0x00);
	// DAPAIR=0, DAOSR=0, ADOSR=0, CONVSR=0
	adau1761_write(pDevice, 0x4017, 0x00);
	// MX3RM=0, MX3LM=1, MX3AUXG=0, MX3EN=1
	adau1761_write(pDevice, 0x401C, 0x21);
	// MX3G2=0, MX3G1=0
	adau1761_write(pDevice, 0x401D, 0x00);
	// MX4RM=1, MX4LM=0, MX4AUXG=0, MX4EN=1
	adau1761_write(pDevice, 0x401E, 0x41);
	// MX4G2=0, MX4G1=0
	adau1761_write(pDevice, 0x401F, 0x00);
	// MX5G4=0, MX5G3=10, MX5EN=1
	adau1761_write(pDevice, 0x4020, 0x05);
	// MX6G4=01, MX6G3=0, MX6EN=1
	adau1761_write(pDevice, 0x4021, 0x11);
	// MX7=0, MX7EN=0
	adau1761_write(pDevice, 0x4022, 0x00);
	// LOUTVOL=63, LOUTM=1, LOMODE=0
	adau1761_write(pDevice, 0x4025, 0xFE);
	// ROUTVOL=63, ROUTM=1, ROMODE=0
	adau1761_write(pDevice, 0x4026, 0xFE);

	// HPBIAS=0, DACBIAS=0, PBIAS=0, PREN=1, PLEN=1
	adau1761_write(pDevice, 0x4029, 0x03);
	// DACMONO=0, DACPOL=0,DEMPH=0, DACEN=3
	adau1761_write(pDevice, 0x402A, 0x03);

	// SINRT=1
	adau1761_write(pDevice, 0x40F2, 0x01);

	xStatus = adau1761_checkInit(pDevice);
	if (xStatus!=0) {
		return xStatus;
	}

	xStatus = XAxiDma_CfgInitialize(&pDevice->dmaAxiController,XAxiDma_LookupConfig(dmaId));
	if(XST_SUCCESS != xStatus) {
		print("Failed to initialize DMA\n\r");
		return -9;
	}

	if(!XAxiDma_HasSg(&pDevice->dmaAxiController)){
		print("Device configured as simple mode\n\r");
		return -10;
	}

	xStatus = adau1761_dmaSetup(pDevice);
	if (xStatus!=0) {
		return xStatus;
	}

	return 0;
}

int adau1761_checkInit(adau1761_config *pDevice) {
	u8 rdata = adau1761_read(pDevice, 0x4000);

	if (rdata!=0x01) {
		return -3;
	}

	return 0;
}

void adau1761_write(adau1761_config *pDevice,u16 addr, u8 wdata) {
	XLlFifo_TxPutWord(&pDevice->spiFifoController, (pDevice->spiChipAddr<<1) & 0xFF);
	XLlFifo_TxPutWord(&pDevice->spiFifoController, (addr>>8) & 0xFF );
	XLlFifo_TxPutWord(&pDevice->spiFifoController, addr & 0xFF );
	XLlFifo_TxPutWord(&pDevice->spiFifoController, wdata );
	XLlFifo_iTxSetLen(&pDevice->spiFifoController, 4 * pDevice->spiFifoWordsize);
	while(XLlFifo_RxOccupancy(&pDevice->spiFifoController)!=4) {}
	XLlFifo_RxGetWord(&pDevice->spiFifoController);
	XLlFifo_RxGetWord(&pDevice->spiFifoController);
	XLlFifo_RxGetWord(&pDevice->spiFifoController);
	XLlFifo_RxGetWord(&pDevice->spiFifoController);
}

u8 adau1761_read(adau1761_config *pDevice,u16 addr) {
	XLlFifo_TxPutWord(&pDevice->spiFifoController, ((pDevice->spiChipAddr<<1) |0x01) & 0xFF);
	XLlFifo_TxPutWord(&pDevice->spiFifoController, (addr>>8) & 0xFF );
	XLlFifo_TxPutWord(&pDevice->spiFifoController, addr & 0xFF );
	XLlFifo_TxPutWord(&pDevice->spiFifoController, 0 );
	XLlFifo_iTxSetLen(&pDevice->spiFifoController, 4 * pDevice->spiFifoWordsize);
	while(XLlFifo_RxOccupancy(&pDevice->spiFifoController)!=4) {}
	XLlFifo_RxGetWord(&pDevice->spiFifoController);
	XLlFifo_RxGetWord(&pDevice->spiFifoController);
	XLlFifo_RxGetWord(&pDevice->spiFifoController);
	u32 rdata = XLlFifo_RxGetWord(&pDevice->spiFifoController);

	return (u8)(rdata & 0xFF);
}

int adau1761_dmaSetup(adau1761_config *pDevice) {
	XAxiDma_BdRing *TxRingPtr = XAxiDma_GetTxRing(&pDevice->dmaAxiController);

	// Disable all TX interrupts before TxBD space setup
	XAxiDma_BdRingIntDisable(TxRingPtr, XAXIDMA_IRQ_ALL_MASK);

	// Setup TxBD space
	u32 BdCount = XAxiDma_BdRingCntCalc(XAXIDMA_BD_MINIMUM_ALIGNMENT,(u32) sizeof(pDevice->dmaBdBuffer));

	int Status = XAxiDma_BdRingCreate(TxRingPtr, (UINTPTR)&pDevice->dmaBdBuffer[0], (UINTPTR)&pDevice->dmaBdBuffer[0], XAXIDMA_BD_MINIMUM_ALIGNMENT, BdCount);
	if (Status != XST_SUCCESS) {
		print("Failed create BD ring\n\r");
		return -11;
	}

	// Like the RxBD space, we create a template and set all BDs to be the
	// same as the template. The sender has to set up the BDs as needed.
	XAxiDma_Bd BdTemplate;
	XAxiDma_BdClear(&BdTemplate);
	Status = XAxiDma_BdRingClone(TxRingPtr, &BdTemplate);
	if (Status != XST_SUCCESS) {
		print("Failed clone BDs\n\r");
		return -12;
	}

	// Start the TX channel
	Status = XAxiDma_BdRingStart(TxRingPtr);
	//Status = XAxiDma_StartBdRingHw(TxRingPtr);
	if (Status != XST_SUCCESS) {
		print("Failed bd start\n\r");
		return -14;
	}

	return 0;
}

int adau1761_dmaBusy(adau1761_config *pDevice) {
	if (pDevice->dmaWritten && XAxiDma_Busy(&pDevice->dmaAxiController,XAXIDMA_DMA_TO_DEVICE)!=0) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}

void adau1761_dmaReset(adau1761_config *pDevice) {
	XAxiDma_Reset(&pDevice->dmaAxiController);
	for(int TimeOut = 2000000;TimeOut>0;--TimeOut) {
		if (XAxiDma_ResetIsDone(&pDevice->dmaAxiController)) {
			break;
		}
	}
}

void adau1761_dmaFreeProcessedBDs(adau1761_config *pDevice) {
	XAxiDma_BdRing *TxRingPtr = XAxiDma_GetTxRing(&pDevice->dmaAxiController);

	// Get all processed BDs from hardware
	XAxiDma_Bd *BdPtr;
	int BdCount = XAxiDma_BdRingFromHw(TxRingPtr, XAXIDMA_ALL_BDS, &BdPtr);

	// Free all processed BDs for future transmission
	int Status = XAxiDma_BdRingFree(TxRingPtr, BdCount, BdPtr);
	if (Status != XST_SUCCESS) {
		print("Failed to free BDs\n\r");
		for(;;);
	}
}

void adau1761_dmaTransmit(adau1761_config *pDevice, u32 *buffer, size_t buffer_len, int nRepeats) {
	XAxiDma_BdRing *TxRingPtr = XAxiDma_GetTxRing(&pDevice->dmaAxiController);

	// Free the processeds BDs from previous run.
	adau1761_dmaFreeProcessedBDs(pDevice);

	// Flush the SrcBuffer before the DMA transfer, in case the Data Cache is enabled
	Xil_DCacheFlushRange((u32)buffer, buffer_len * sizeof(u32));

	XAxiDma_Bd *BdPtr = NULL;
	int Status = XAxiDma_BdRingAlloc(TxRingPtr, nRepeats, &BdPtr);
	if (Status != XST_SUCCESS) {
		print("Failed bd alloc\n\r");
		for(;;);
	}

	XAxiDma_Bd *BdCurPtr = BdPtr;;
	for(int i=0;i<nRepeats;++i) {
		Status = XAxiDma_BdSetBufAddr(BdCurPtr, (UINTPTR)buffer);
		if (Status != XST_SUCCESS) {
			print("Tx set buffer addr failed\n\r");
			for(;;);
		}

		Status = XAxiDma_BdSetLength(BdCurPtr, buffer_len*sizeof(u32),	TxRingPtr->MaxTransferLen);
		if (Status != XST_SUCCESS) {
			print("Tx set length failed\n\r");
			for(;;);
		}

		u32 CrBits = 0;
		if (i==0) {
			CrBits |= XAXIDMA_BD_CTRL_TXSOF_MASK; // First BD
		}
		else if (i==nRepeats-1) {
			CrBits |= XAXIDMA_BD_CTRL_TXEOF_MASK; // Last BD
		}
		XAxiDma_BdSetCtrl(BdCurPtr, CrBits);

		XAxiDma_BdSetId(BdCurPtr, (UINTPTR)buffer);

		BdCurPtr = (XAxiDma_Bd *)XAxiDma_BdRingNext(TxRingPtr, BdCurPtr);
	}

	// Give the BD to hardware
	Status = XAxiDma_BdRingToHw(TxRingPtr, nRepeats, BdPtr);
	if (Status != XST_SUCCESS) {
		print("Failed to hw\n\r");
		for(;;);
	}

	pDevice->dmaWritten = TRUE;
}

adau1761_config codec;

// 128 samples = 39.0625 kHz/128 = 305Hz
#define PERIODSAMPLES 128

int main()
{
    init_platform();

    print("Hello World\n\r");

    u32 buffer[PERIODSAMPLES];
    double amp = 16384;
    for(int i=0;i<PERIODSAMPLES;++i) {
    	short left = (short) (cos((double)i/PERIODSAMPLES*2*M_PI) * amp);
    	short right = (short) (sin((double)i/PERIODSAMPLES*2*M_PI) * amp);
    	buffer[i] = ((u32)left<<16) + (u32)right;
    }

	print("Initializing ADAU1761 ... ");
    if (adau1761_init(&codec, XPAR_AXI_FIFO_MM_S_0_DEVICE_ID, XPAR_AXI_DMA_0_DEVICE_ID, XPAR_FABRIC_AXI_DMA_0_MM2S_INTROUT_INTR)==0) {
    	print("OK\n\r");
    }
    else {
    	print("FAILED\n\r");
    }

	print("SPACE:  Status\n\r");
	print("RETURN: Transmit\n\r");
	print("ESC:    End\n\r");
    setvbuf(stdin, NULL, _IONBF, 0);
    for(;;) {
    	int c = getchar();
    	switch (c) {
			case 13: 	adau1761_dmaTransmit(&codec, buffer, PERIODSAMPLES, 200);
						break;
			case 32:	printf("BUSY: %d\n\r", adau1761_dmaBusy(&codec));
						break;
    	}

    	if (c==27) break;
    }

	adau1761_dmaReset(&codec);

	print("Good bye\n\r");

    cleanup_platform();
    return 0;
}
