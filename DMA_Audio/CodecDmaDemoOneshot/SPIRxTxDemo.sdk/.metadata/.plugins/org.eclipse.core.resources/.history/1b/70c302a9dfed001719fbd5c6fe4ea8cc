/******************************************************************************
*
* Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* Use of the Software is limited solely to applications:
* (a) running on a Xilinx device, or
* (b) that interact with a Xilinx device through a bus or interconnect.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* Except as contained in this notice, the name of the Xilinx shall not be used
* in advertising or otherwise to promote the sale, use or other dealings in
* this Software without prior written authorization from Xilinx.
*
******************************************************************************/

/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include <stdio.h>
#include <math.h>
#include "platform.h"
#include "xil_printf.h"

#include "xil_types.h"
#include "xstatus.h"
#include "xllfifo.h"
#include "xscugic.h"
#include "xaxidma.h"
#include "xparameters.h"

#define BDUFFERSIZE 4000

typedef struct
{
	XLlFifo fifo_spi;
	XScuGic intCtrl;
	u8 chipAddr;
	int wordSize;
	u32 *buffer;
	size_t buffersize;
	XAxiDma AxiDma;
	XAxiDma_Bd BdBuffer[BDUFFERSIZE] __attribute__((aligned(XAXIDMA_BD_MINIMUM_ALIGNMENT)));
	int dmaHold;
} adau1761_config;

int adau1761_init(adau1761_config *pDevice, u32 DeviceId, u16 dmaId, u16 interruptId, u32 *buffer_in, size_t buffersize_in);
int adau1761_checkInit(adau1761_config *pDevice);
void adau1761_write(adau1761_config *pDevice,u16 addr, u8 wdata);
u8 adau1761_read(adau1761_config *pDevice,u16 addr);
int adau1761_setupInterruptSystem(adau1761_config *pDevice, u16 interruptId);
int adau1761_dmaSetup(adau1761_config *pDevice);
void adau1761_dmaRestart(adau1761_config *pDevice);

int adau1761_init(adau1761_config *pDevice, u32 DeviceId, u16 dmaId, u16 interruptId, u32 *buffer_in, size_t buffersize_in) {
	pDevice->chipAddr = 0;
	pDevice->wordSize = 4;
	pDevice->buffer = buffer_in;
	pDevice->buffersize = buffersize_in;
	pDevice->dmaHold = FALSE;

	XLlFifo_Config *pConfig = XLlFfio_LookupConfig(DeviceId);
	int xStatus = XLlFifo_CfgInitialize(&pDevice->fifo_spi,pConfig,pConfig->BaseAddress);
	if(XST_SUCCESS != xStatus) {
		return -1;
	}

	// Check for the Reset value
	u32 Status = XLlFifo_Status(&pDevice->fifo_spi);
	XLlFifo_IntClear(&pDevice->fifo_spi,0xffffffff);
	Status = XLlFifo_Status(&pDevice->fifo_spi);
	if(Status != 0) {
		return -2;
	}

	// This enables SPI mode
	adau1761_read(pDevice, 0x4000);
	adau1761_read(pDevice, 0x4000);
	adau1761_read(pDevice, 0x4000);

	// Enable clock
	adau1761_write(pDevice, 0x4000, 0x01);

	// SLEWPD=1, ALCPD=1, DECPD=1, SOUTPD=1, INTPD=1, SINPD=1, SPPD=1
	adau1761_write(pDevice, 0x40F9, 0x7F);
	// CLK1=0, CLK0=1
	adau1761_write(pDevice, 0x40FA, 0x01);

	// MX3LM=1, MX3RM=0, MX3G1=0, MX3G2=0, MX3AUXG=0, MX5G3=3, MX6G3=0, LOUTVOL=63
	// MX4LM=0, MX4RM=1, MX4G1=0, MX4G2=0, MX4AUXG=0, MX5G4=0, MX6G4=3, ROUTVOL=63

	// LRCLK/LRPOL=falling edge, LRCLK/LRMOD=50%, BCLK/BPOL=falloing edge, LRDEL=1
	// SPSRS=0, LRMOD=0, BPOL=0, LRPOL=0, CHPF=0, MS=0
	adau1761_write(pDevice, 0x4015, 0x00);
	// BPF=0, ADTDM=0, DATDM=0, MSBP=0, LRDEL=0
	adau1761_write(pDevice, 0x4016, 0x00);
	// DAPAIR=0, DAOSR=0, ADOSR=0, CONVSR=0
	adau1761_write(pDevice, 0x4017, 0x00);
	// MX3RM=0, MX3LM=1, MX3AUXG=0, MX3EN=1
	adau1761_write(pDevice, 0x401C, 0x21);
	// MX3G2=0, MX3G1=0
	adau1761_write(pDevice, 0x401D, 0x00);
	// MX4RM=1, MX4LM=0, MX4AUXG=0, MX4EN=1
	adau1761_write(pDevice, 0x401E, 0x41);
	// MX4G2=0, MX4G1=0
	adau1761_write(pDevice, 0x401F, 0x00);
	// MX5G4=0, MX5G3=10, MX5EN=1
	adau1761_write(pDevice, 0x4020, 0x05);
	// MX6G4=01, MX6G3=0, MX6EN=1
	adau1761_write(pDevice, 0x4021, 0x11);
	// MX7=0, MX7EN=0
	adau1761_write(pDevice, 0x4022, 0x00);
	// LOUTVOL=63, LOUTM=1, LOMODE=0
	adau1761_write(pDevice, 0x4025, 0xFE);
	// ROUTVOL=63, ROUTM=1, ROMODE=0
	adau1761_write(pDevice, 0x4026, 0xFE);

	// HPBIAS=0, DACBIAS=0, PBIAS=0, PREN=1, PLEN=1
	adau1761_write(pDevice, 0x4029, 0x03);
	// DACMONO=0, DACPOL=0,DEMPH=0, DACEN=3
	adau1761_write(pDevice, 0x402A, 0x03);

	// SINRT=1
	adau1761_write(pDevice, 0x40F2, 0x01);

	xStatus = adau1761_checkInit(pDevice);
	if (xStatus!=0) {
		return xStatus;
	}

	xStatus = XAxiDma_CfgInitialize(&pDevice->AxiDma,XAxiDma_LookupConfig(dmaId));
	if(XST_SUCCESS != xStatus) {
		print("Failed to initialize DMA\n\r");
		return -9;
	}

	if(!XAxiDma_HasSg(&pDevice->AxiDma)){
		print("Device configured as simple mode\n\r");
		return -10;
	}

	xStatus = adau1761_dmaSetup(pDevice);
	if (xStatus!=0) {
		return xStatus;
	}

	xStatus = adau1761_setupInterruptSystem(pDevice, interruptId);
	if (xStatus!=0) {
		return xStatus;
	}

	// Enable interrupt output of the FIFO
	XAxiDma_IntrDisable(&pDevice->AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA);
	XAxiDma_IntrDisable(&pDevice->AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DMA_TO_DEVICE);

	XAxiDma_IntrEnable(&pDevice->AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DMA_TO_DEVICE);

	//adau1761_dmaRestart(pDevice);

	return 0;
}

int adau1761_checkInit(adau1761_config *pDevice) {
	u8 rdata = adau1761_read(pDevice, 0x4000);

	if (rdata!=0x01) {
		return -3;
	}

	return 0;
}

void adau1761_write(adau1761_config *pDevice,u16 addr, u8 wdata) {
	XLlFifo_TxPutWord(&pDevice->fifo_spi, (pDevice->chipAddr<<1) & 0xFF);
	XLlFifo_TxPutWord(&pDevice->fifo_spi, (addr>>8) & 0xFF );
	XLlFifo_TxPutWord(&pDevice->fifo_spi, addr & 0xFF );
	XLlFifo_TxPutWord(&pDevice->fifo_spi, wdata );
	XLlFifo_iTxSetLen(&pDevice->fifo_spi, 4 * pDevice->wordSize);
	while(XLlFifo_RxOccupancy(&pDevice->fifo_spi)!=4) {}
	XLlFifo_RxGetWord(&pDevice->fifo_spi);
	XLlFifo_RxGetWord(&pDevice->fifo_spi);
	XLlFifo_RxGetWord(&pDevice->fifo_spi);
	XLlFifo_RxGetWord(&pDevice->fifo_spi);
}

u8 adau1761_read(adau1761_config *pDevice,u16 addr) {
	XLlFifo_TxPutWord(&pDevice->fifo_spi, ((pDevice->chipAddr<<1) |0x01) & 0xFF);
	XLlFifo_TxPutWord(&pDevice->fifo_spi, (addr>>8) & 0xFF );
	XLlFifo_TxPutWord(&pDevice->fifo_spi, addr & 0xFF );
	XLlFifo_TxPutWord(&pDevice->fifo_spi, 0 );
	XLlFifo_iTxSetLen(&pDevice->fifo_spi, 4 * pDevice->wordSize);
	while(XLlFifo_RxOccupancy(&pDevice->fifo_spi)!=4) {}
	XLlFifo_RxGetWord(&pDevice->fifo_spi);
	XLlFifo_RxGetWord(&pDevice->fifo_spi);
	XLlFifo_RxGetWord(&pDevice->fifo_spi);
	u32 rdata = XLlFifo_RxGetWord(&pDevice->fifo_spi);

	return (u8)(rdata & 0xFF);
}

int adau1761_dmaSetup(adau1761_config *pDevice) {
	XAxiDma_BdRing *TxRingPtr = XAxiDma_GetTxRing(&pDevice->AxiDma);

	// Disable all TX interrupts before TxBD space setup
	XAxiDma_BdRingIntDisable(TxRingPtr, XAXIDMA_IRQ_ALL_MASK);

	// Setup TxBD space
	u32 BdCount = XAxiDma_BdRingCntCalc(XAXIDMA_BD_MINIMUM_ALIGNMENT,(u32) sizeof(pDevice->BdBuffer));

	int Status = XAxiDma_BdRingCreate(TxRingPtr, (UINTPTR)&pDevice->BdBuffer[0], (UINTPTR)&pDevice->BdBuffer[0], XAXIDMA_BD_MINIMUM_ALIGNMENT, BdCount);
	if (Status != XST_SUCCESS) {
		print("Failed create BD ring\n\r");
		return -11;
	}

	// Like the RxBD space, we create a template and set all BDs to be the
	// same as the template. The sender has to set up the BDs as needed.
	XAxiDma_Bd BdTemplate;
	XAxiDma_BdClear(&BdTemplate);
	Status = XAxiDma_BdRingClone(TxRingPtr, &BdTemplate);
	if (Status != XST_SUCCESS) {
		print("Failed clone BDs\n\r");
		return -12;
	}

	// Set the coalescing threshold, so only one transmit interrupt
	// occurs for this example
	// If you would like to have multiple interrupts to happen, change
	// the COALESCING_COUNT to be a smaller value
	#define DELAY_TIMER_COUNT		100
	Status = XAxiDma_BdRingSetCoalesce(TxRingPtr, 1,	DELAY_TIMER_COUNT);
	if (Status != XST_SUCCESS) {
		print("Failed set coalescing\n\r");
		return -13;
	}

	//XAxiDma_SelectCyclicMode(&pDevice->AxiDma,XAXIDMA_DMA_TO_DEVICE, TRUE);

	// Enable all TX interrupts
	XAxiDma_BdRingIntEnable(TxRingPtr, XAXIDMA_IRQ_ALL_MASK);

	// Start the TX channel
	//Status = XAxiDma_BdRingStart(TxRingPtr);
	Status = XAxiDma_StartBdRingHw(TxRingPtr);
	if (Status != XST_SUCCESS) {
		print("Failed bd start\n\r");
		return -14;
	}

	return 0;
}

void adau1761_dmaInterruptHandler(adau1761_config *pDevice) {
	// Hint: After one transfer, we will receive an XAXIDMA_IRQ_IOC_MASK interrupt. If we wait a while,
	// we will receive an XAXIDMA_IRQ_DELAY_MASK interrupt

	XAxiDma_BdRing *TxRingPtr = XAxiDma_GetTxRing(&pDevice->AxiDma);

	// Read pending interrupts
	u32 IrqStatus = XAxiDma_BdRingGetIrq(TxRingPtr);

	// Acknowledge pending interrupts
	XAxiDma_BdRingAckIrq(TxRingPtr, IrqStatus);

	// If error interrupt is asserted, raise error flag, reset the
	// hardware to recover from the error, and return with no further processing.
	if ((IrqStatus & XAXIDMA_IRQ_ERROR_MASK)) {
		XAxiDma_BdRingDumpRegs(TxRingPtr);

		XAxiDma_Reset(&pDevice->AxiDma);

		for(int TimeOut = 2000000;TimeOut>0;--TimeOut) {
			if (XAxiDma_ResetIsDone(&pDevice->AxiDma)) {
				break;
			}
		}
		return;
	}
	// If Completion interrupt is asserted, then set the TxDone flag
	else if ((IrqStatus & (XAXIDMA_IRQ_DELAY_MASK | XAXIDMA_IRQ_IOC_MASK))) {
		/*
		// Get all processed BDs from hardware
		XAxiDma_Bd *BdPtr;
		int BdCount = XAxiDma_BdRingFromHw(TxRingPtr, XAXIDMA_ALL_BDS, &BdPtr);

		XAxiDma_Bd *BdCurPtr = BdPtr;
		for (int i = 0; i < BdCount; i++) {
			// Check the status in each BD
			u32 BdSts = XAxiDma_BdGetSts(BdCurPtr);
			if ((BdSts & XAXIDMA_BD_STS_ALL_ERR_MASK) || (!(BdSts & XAXIDMA_BD_STS_COMPLETE_MASK))) {
				print("Transfer Failed\n\r");
				for(;;);
			}

			BdCurPtr = (XAxiDma_Bd *)XAxiDma_BdRingNext(TxRingPtr, BdCurPtr);
		}

		// Free all processed BDs for future transmission
		int Status = XAxiDma_BdRingFree(TxRingPtr, BdCount, BdPtr);
		if (Status != XST_SUCCESS) {
			print("XAxiDma_BdRingFree() Failed\n\r");
			for(;;);
		}

		if (!pDevice->dmaHold) {
			//adau1761_dmaRestart(pDevice);
		}
		*/
	}
}

#define XAXIDMA_RING_SEEKAHEAD(RingPtr, BdPtr, NumBd)                \
    {                                                                \
        UINTPTR Addr = (UINTPTR)(void *)(BdPtr);                                     \
                                                                     \
        Addr += ((RingPtr)->Separation * (NumBd));                   \
        if ((Addr > (RingPtr)->LastBdAddr) || ((UINTPTR)(BdPtr) > Addr)) \
        {                                                            \
            Addr -= (RingPtr)->Length;                               \
        }                                                            \
                                                                     \
        (BdPtr) = (XAxiDma_Bd*)(void *)Addr;                                 \
    }

#define XAXIDMA_VIRT_TO_PHYS(BdPtr) \
	((UINTPTR)(BdPtr) + (RingPtr->FirstBdPhysAddr - RingPtr->FirstBdAddr))

int MyXAxiDma_BdRingToHw(XAxiDma_BdRing * RingPtr, int NumBd, XAxiDma_Bd * BdSetPtr, int tailOffset)
{
	XAxiDma_Bd *CurBdPtr;
	int i;
	u32 BdCr;
	u32 BdSts;
	int RingIndex = RingPtr->RingIndex;

	if (NumBd < 0) {

		xdbg_printf(XDBG_DEBUG_ERROR, "BdRingToHw: negative BD number "
			"%d\r\n", NumBd);

		return XST_INVALID_PARAM;
	}

	/* If the commit set is empty, do nothing */
	if (NumBd == 0) {
		return XST_SUCCESS;
	}

	/* Make sure we are in sync with XAxiDma_BdRingAlloc() */
	if ((RingPtr->PreCnt < NumBd) || (RingPtr->PreHead != BdSetPtr)) {

		xdbg_printf(XDBG_DEBUG_ERROR, "Bd ring has problems\r\n");
		return XST_DMA_SG_LIST_ERROR;
	}

	CurBdPtr = BdSetPtr;
	BdCr = XAxiDma_BdGetCtrl(CurBdPtr);
	BdSts = XAxiDma_BdGetSts(CurBdPtr);

	/* In case of Tx channel, the first BD should have been marked
	 * as start-of-frame
	 */
	if (!(RingPtr->IsRxChannel) && !(BdCr & XAXIDMA_BD_CTRL_TXSOF_MASK)) {

		xdbg_printf(XDBG_DEBUG_ERROR, "Tx first BD does not have "
								"SOF\r\n");

		return XST_FAILURE;
	}

	/* Clear the completed status bit
	 */
	for (i = 0; i < NumBd - 1; i++) {

		/* Make sure the length value in the BD is non-zero. */
		if (XAxiDma_BdGetLength(CurBdPtr,
				RingPtr->MaxTransferLen) == 0) {

			xdbg_printf(XDBG_DEBUG_ERROR, "0 length bd\r\n");

			return XST_FAILURE;
		}

		BdSts &=  ~XAXIDMA_BD_STS_COMPLETE_MASK;
		XAxiDma_BdWrite(CurBdPtr, XAXIDMA_BD_STS_OFFSET, BdSts);

		/* Flush the current BD so DMA core could see the updates */
		XAXIDMA_CACHE_FLUSH(CurBdPtr);

		CurBdPtr = (XAxiDma_Bd *)((void *)XAxiDma_BdRingNext(RingPtr, CurBdPtr));
		BdCr = XAxiDma_BdRead(CurBdPtr, XAXIDMA_BD_CTRL_LEN_OFFSET);
		BdSts = XAxiDma_BdRead(CurBdPtr, XAXIDMA_BD_STS_OFFSET);
	}

	/* In case of Tx channel, the last BD should have EOF bit set */
//	if (!(RingPtr->IsRxChannel) && !(BdCr & XAXIDMA_BD_CTRL_TXEOF_MASK)) {
//
//		xdbg_printf(XDBG_DEBUG_ERROR, "Tx last BD does not have "
//								"EOF\r\n");
//
//		return XST_FAILURE;
//	}

	/* Make sure the length value in the last BD is non-zero. */
	if (XAxiDma_BdGetLength(CurBdPtr,
			RingPtr->MaxTransferLen) == 0) {

		xdbg_printf(XDBG_DEBUG_ERROR, "0 length bd\r\n");

		return XST_FAILURE;
	}

	/* The last BD should also have the completed status bit cleared
	 */
	BdSts &= ~XAXIDMA_BD_STS_COMPLETE_MASK;
	XAxiDma_BdWrite(CurBdPtr, XAXIDMA_BD_STS_OFFSET, BdSts);

	/* Flush the last BD so DMA core could see the updates */
	XAXIDMA_CACHE_FLUSH(CurBdPtr);
	DATA_SYNC;

	/* This set has completed pre-processing, adjust ring pointers and
	 * counters
	 */
	XAXIDMA_RING_SEEKAHEAD(RingPtr, RingPtr->PreHead, NumBd);
	RingPtr->PreCnt -= NumBd;
	RingPtr->HwTail = CurBdPtr + tailOffset; //!!! Needed for cyclic DMA. Needs to point outside the chain.
	RingPtr->HwCnt += NumBd;

	/* If it is running, signal the engine to begin processing */
	if (RingPtr->RunState == AXIDMA_CHANNEL_NOT_HALTED) {
			if (RingPtr->IsRxChannel) {
				if (!RingIndex) {
					XAxiDma_WriteReg(RingPtr->ChanBase,
							XAXIDMA_TDESC_OFFSET, (XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail) & XAXIDMA_DESC_LSB_MASK));
					if (RingPtr->Addr_ext)
						XAxiDma_WriteReg(RingPtr->ChanBase, XAXIDMA_TDESC_MSB_OFFSET,
								 UPPER_32_BITS(XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail)));
				}
				else {
					XAxiDma_WriteReg(RingPtr->ChanBase,
						(XAXIDMA_RX_TDESC0_OFFSET +
						(RingIndex - 1) * XAXIDMA_RX_NDESC_OFFSET),
						(XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail) & XAXIDMA_DESC_LSB_MASK ));
					if (RingPtr->Addr_ext)
						XAxiDma_WriteReg(RingPtr->ChanBase,
							(XAXIDMA_RX_TDESC0_MSB_OFFSET +
							(RingIndex - 1) * XAXIDMA_RX_NDESC_OFFSET),
							UPPER_32_BITS(XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail)));
				}
			}
			else {
				XAxiDma_WriteReg(RingPtr->ChanBase,
							XAXIDMA_TDESC_OFFSET, (XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail) & XAXIDMA_DESC_LSB_MASK));
				if (RingPtr->Addr_ext)
					XAxiDma_WriteReg(RingPtr->ChanBase, XAXIDMA_TDESC_MSB_OFFSET,
								UPPER_32_BITS(XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail)));
			}
	}

	return XST_SUCCESS;
}

void adau1761_dmaRestart(adau1761_config *pDevice) {
	XAxiDma_BdRing *TxRingPtr = XAxiDma_GetTxRing(&pDevice->AxiDma);

	// Flush the SrcBuffer before the DMA transfer, in case the Data Cache is enabled
	Xil_DCacheFlushRange((u32)pDevice->buffer, pDevice->buffersize*4);

	XAxiDma_Bd *BdPtr = NULL;
	const int nBD = 1;
	int Status = XAxiDma_BdRingAlloc(TxRingPtr, nBD, &BdPtr);
	if (Status != XST_SUCCESS) {
		print("Failed bd alloc\n\r");
		for(;;);
	}

	Status = XAxiDma_BdSetBufAddr(BdPtr, (UINTPTR)pDevice->buffer);
	if (Status != XST_SUCCESS) {
		print("Tx set buffer addr failed\n\r");
		for(;;);
	}

	Status = XAxiDma_BdSetLength(BdPtr, pDevice->buffersize*4,	TxRingPtr->MaxTransferLen);
	if (Status != XST_SUCCESS) {
		print("Tx set length failed\n\r");
		for(;;);
	}

	u32 CrBits = 0;
	CrBits |= XAXIDMA_BD_CTRL_TXSOF_MASK; // First BD
	CrBits |= XAXIDMA_BD_CTRL_TXEOF_MASK; // Last BD
	XAxiDma_BdSetCtrl(BdPtr, CrBits);

	XAxiDma_BdSetId(BdPtr, (UINTPTR)pDevice->buffer);

	// Give the BD to hardware
	Status = MyXAxiDma_BdRingToHw(TxRingPtr, nBD, BdPtr , 100);
	if (Status != XST_SUCCESS) {
		print("Failed to hw\n\r");
		for(;;);
	}
}

int adau1761_setupInterruptSystem(adau1761_config *pDevice, u16 interruptId)
{
	// Initialize the interrupt controller driver so that it is ready to use.
	XScuGic_Config *IntcConfig = XScuGic_LookupConfig(XPAR_SCUGIC_SINGLE_DEVICE_ID);
	if (NULL == IntcConfig) {
		print("XScuGic_LookupConfig() failed\n\r");
		return -6;
	}

	int Status = XScuGic_CfgInitialize(&pDevice->intCtrl, IntcConfig,IntcConfig->CpuBaseAddress);
	if (Status != XST_SUCCESS) {
		print("XScuGic_CfgInitialize() failed\n\r");
		return -7;
	}

	XScuGic_SetPriorityTriggerType(&pDevice->intCtrl, interruptId, 0xA0, 0x3);

	// Connect the device driver handler that will be called when an
	// interrupt for the device occurs, the handler defined above performs
	// the specific interrupt processing for the device.
	Status = XScuGic_Connect(&pDevice->intCtrl, interruptId,(Xil_InterruptHandler)adau1761_dmaInterruptHandler,pDevice);
	if (Status != XST_SUCCESS) {
		print("XScuGic_Connect() failed\n\r");
		return -8;
	}

	XScuGic_Enable(&pDevice->intCtrl, interruptId);

	// Initialize the exception table.
	Xil_ExceptionInit();

	// Register the interrupt controller handler with the exception table.
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,(Xil_ExceptionHandler)XScuGic_InterruptHandler,(void *)&pDevice->intCtrl);

	// Enable exceptions.
	Xil_ExceptionEnable();

	return 0;
}

void adau1761_dmaTransmit(adau1761_config *pDevice, u32 *buffer, size_t buffer_len, int nRepeats) {
	XAxiDma_BdRing *TxRingPtr = XAxiDma_GetTxRing(&pDevice->AxiDma);

	/* Flush the SrcBuffer before the DMA transfer, in case the Data Cache
		 * is enabled
		 */
	// Flush the SrcBuffer before the DMA transfer, in case the Data Cache is enabled
	Xil_DCacheFlushRange((u32)buffer, buffer_len * sizeof(u32));

	XAxiDma_Bd *BdPtr = NULL;
	int Status = XAxiDma_BdRingAlloc(TxRingPtr, nRepeats, &BdPtr);
	if (Status != XST_SUCCESS) {
		print("Failed bd alloc\n\r");
		for(;;);
	}

	XAxiDma_Bd *BdCurPtr = BdPtr;;
	for(int i=0;i<nRepeats;++i) {
		Status = XAxiDma_BdSetBufAddr(BdCurPtr, (UINTPTR)buffer);
		if (Status != XST_SUCCESS) {
			print("Tx set buffer addr failed\n\r");
			for(;;);
		}

		Status = XAxiDma_BdSetLength(BdCurPtr, buffer_len*sizeof(u32),	TxRingPtr->MaxTransferLen);
		if (Status != XST_SUCCESS) {
			print("Tx set length failed\n\r");
			for(;;);
		}

		u32 CrBits = 0;
		if (i==0) {
			CrBits |= XAXIDMA_BD_CTRL_TXSOF_MASK; // First BD
		}
		else if (i==nRepeats-1) {
			CrBits |= XAXIDMA_BD_CTRL_TXEOF_MASK; // Last BD
		}
		XAxiDma_BdSetCtrl(BdCurPtr, CrBits);

		XAxiDma_BdSetId(BdCurPtr, (UINTPTR)buffer);

		BdCurPtr = (XAxiDma_Bd *)XAxiDma_BdRingNext(TxRingPtr, BdCurPtr);
	}

	// Give the BD to hardware
	Status = XAxiDma_BdRingToHw(TxRingPtr, nRepeats, BdPtr);
	if (Status != XST_SUCCESS) {
		print("Failed to hw\n\r");
		for(;;);
	}
}

adau1761_config codec;

// 128 samples = 39.0625 kHz/128 = 305Hz
#define PERIODSAMPLES 128

int main()
{
    init_platform();

    print("Hello World\n\r");

    u32 buffer[PERIODSAMPLES];
    double amp = 16384;
    for(int i=0;i<PERIODSAMPLES;++i) {
    	short left = (short) (cos((double)i/PERIODSAMPLES*2*M_PI) * amp);
    	short right = (short) (sin((double)i/PERIODSAMPLES*2*M_PI) * amp);
    	buffer[i] = ((u32)left<<16) + (u32)right;
    }

	print("Initializing ADAU1761 ... ");
    if (adau1761_init(&codec, XPAR_AXI_FIFO_MM_S_0_DEVICE_ID, XPAR_AXI_DMA_0_DEVICE_ID, XPAR_FABRIC_AXI_DMA_0_MM2S_INTROUT_INTR,
    		buffer,PERIODSAMPLES)==0) {
    	print("OK\n\r");
    }
    else {
    	print("FAILED\n\r");
    }

    print("Press RETURN\n\r");
    getchar();

    adau1761_dmaTransmit(&codec, buffer, PERIODSAMPLES, 200);

	print("Good bye\n\r");

    cleanup_platform();
    return 0;
}
